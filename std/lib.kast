# BrainoidGames: do you have type casting yet? if not, can we name it kast()?

syntax then <- 0 = a ";" b;
syntax then <- 0 = a ";";

syntax break_impl <- 3 = "break" value;
syntax break_impl <- 3 = "break";
syntax continue_impl <- 3 = "continue";

syntax let <- 5 = "let" pattern "=" value;
syntax const_let <- 5 = "const" pattern "=" value;

syntax unwinding <- 6 = "unwinding" def;
syntax with_context <- 6 = "with" new_context "(" expr ")";
syntax current_context <- 6 = "current" context_type;
syntax macro <- 6 = "macro" def;
syntax comptime <- 6 = "comptime" value;

syntax function_def <- 7 = args "=>" body;

syntax type_ascribe <- 8 = value "::" type;

syntax template_def <- 9 = "forall" args "." def;
syntax template_def <- 9 = "forall" args "where" where "." def;

syntax function_type -> 10 = arg "->" result;
syntax function_type -> 10 = arg "->" result "incontext" contexts;

syntax tuple <- 11 = a "," b;
syntax tuple <- 11 = a ",";
syntax field <- 12 = name ":" value;
syntax inline_field <- 12 = "~" name;

syntax if <- 13 = "if" cond "then" then;
syntax if <- 13 = "if" cond "then" then "else" else;
syntax if -> 13 = cond "?" then ":" else;
syntax if -> 13 = cond "then" then "else" else;

syntax implements <- 14 = type "implements" trait;

syntax pipe <- 15 = args "|>" f;
syntax pipe <- 15 = f "<|" args;

syntax or <- 17 = lhs "or" rhs;
syntax and <- 18 = lhs "and" rhs;

syntax less <- 19 = lhs "<" rhs;
syntax less_or_equal <- 19 = lhs "<=" rhs;
syntax equal <- 19 = lhs "==" rhs;
syntax not_equal <- 19 = lhs "!=" rhs;
syntax greater_or_equal <- 19 = lhs ">=" rhs;
syntax greater <- 19 = lhs ">" rhs;

syntax uplus <- 20 = "+" x;
syntax negate <- 20 = "-" x;
syntax add <- 20 = lhs "+" rhs;
syntax sub <- 20 = lhs "-" rhs;

syntax mul <- 40 = lhs "*" rhs;
syntax div <- 40 = lhs "/" rhs;
syntax mod <- 40 = lhs "%" rhs;

syntax pow -> 60 = lhs "^" rhs;

syntax call <- 100 = f args;

syntax typeof <- 120 = "typeof" expr;
syntax typeofvalue <- 120 = "typeofvalue" expr;

syntax instantiate_template <- 150 = template "[" args "]";

syntax quote -> 200 = "`" expr;
syntax quote -> 200 = "`" "(" expr ")";
syntax unquote -> 200 = "$" expr;
syntax unquote -> 200 = "$" "(" expr ")";

syntax field_access <- 300 = obj "." field;

syntax function_def <- 500 = "fn" "(" args ")" contexts "{" body "}";
syntax function_def <- 500 = "fn" "(" args ")" "{" body "}";
syntax function_def <- 100000 = "(" args ")" "{" body "}";
syntax function_def <- 100000 = "(" ")" "{" body "}";
syntax function_def <- 100000 = "{" body "}";

syntax scope <- 100000 = "(" e ")";
syntax unit <- 100000 = "(" ")";

# let option = Some value | None

const inline_field = macro name : name => `($name : $name);

# args |> f
const pipe = macro ~f, ~args => `((
    let args = $args;
    let f = $f;
    f args
));

let loop_context = (
    finish_current_iteration: (bool -> never), # todo should be option[T] -> never
);

# todo
# with = forall (arg :: type, result :: type, old_context :: type, new_context :: type).
# fn (body :: arg -> result incontext (old_context and new_context)) old_context {
# body arg
# }

let loop = fn (body :: (void -> void incontext loop_context)) {
    let should_continue = unwinding (token :: unwind_token) {
        let current_loop_context = (
            finish_current_iteration: (x :: bool => unwind ( ~token, value: x ) ),
        );
        with current_loop_context (
            body ();
            true
        )
    };
    if should_continue then (loop body);
};

let do_break = fn (value :: void) loop_context {
    (current loop_context).finish_current_iteration false
};

let do_continue = fn (void) loop_context {
    (current loop_context).finish_current_iteration true
};

let continue_impl = macro (args :: any) => (
    `(do_continue ())
);

let break_impl = macro (args :: any) => (
    let value :: ast = field_access (
        obj: `(args),
        field: `(value),
        default_value: `(`(void)),
    );
    `(do_break $value)
);

let random = forall (T :: type). (
    if is_same_type (a: T, b: int32) then
        random_int32
    else (if is_same_type (a: T, b: float64) then
        random_float64
    else
        panic "wtf")
);

let parse = forall (T :: type). (
    if is_same_type (a: T, b: int32) then
        string_to_int32
    else
        panic "not implemented"
);

()
